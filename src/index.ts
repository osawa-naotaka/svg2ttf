/*
 * Copyright: Vitaly Puzrin
 * Author: Sergey Batishchev <snb2003@rambler.ru>
 *
 * Written for fontello.com project.
 */

import type MicroBuffer from "./lib/microbuffer";
import SvgPath from "svgpath";
import * as sfnt from "./lib/sfnt.js";
import * as svg from "./lib/svg.js";
import ucs2 from "./lib/ucs2.js";

const VERSION_RE = /^(Version )?(\d+[.]\d+)$/i;

export interface Svg2TtfOptions {
    id?: string;
    familyname?: string;
    copyright?: string;
    description?: string;
    url?: string;
    subfamilyname?: string;
    fullname?: string;
    version?: string;
    ts?: string | number;
}

function svg2ttf(svgString: string, options?: Svg2TtfOptions): MicroBuffer {
    const font = new sfnt.Font();
    const svgFont = svg.load(svgString);

    options = options || {};

    font.id = options.id || svgFont.id;
    font.familyName = options.familyname || svgFont.familyName || svgFont.id;
    font.copyright = options.copyright || svgFont.metadata || "";
    font.description = options.description || "Generated by svg2ttf from Fontello project.";
    font.url = options.url || "http://fontello.com";
    font.sfntNames.push({ id: 2, value: options.subfamilyname || svgFont.subfamilyName || "Regular" }); // subfamily name
    font.sfntNames.push({ id: 4, value: options.fullname || svgFont.id }); // full name

    let versionString = options.version || "Version 1.0";

    if (typeof versionString !== "string") {
        throw new Error("svg2ttf: version option should be a string");
    }
    if (!VERSION_RE.test(versionString)) {
        throw new Error(`svg2ttf: invalid option, version - "${options.version}"`);
    }

    const versionMatch = versionString.match(VERSION_RE);
    versionString = `Version ${versionMatch?.[2] ?? "1.0"}`;
    font.sfntNames.push({ id: 5, value: versionString }); // version ID for TTF name table
    font.sfntNames.push({
        id: 6,
        value: (options.fullname || svgFont.id).replace(/[\s()[\]<>%/]/g, "").substring(0, 62),
    }); // Postscript name for the font, required for OSX Font Book

    if (typeof options.ts !== "undefined") {
        font.createdDate = font.modifiedDate = new Date(Number.parseInt(options.ts.toString(), 10) * 1000);
    }

    // Try to fill font metrics or guess defaults
    //
    font.unitsPerEm = svgFont.unitsPerEm || 1000;
    font.horizOriginX = svgFont.horizOriginX || 0;
    font.horizOriginY = svgFont.horizOriginY || 0;
    font.vertOriginX = svgFont.vertOriginX || 0;
    font.vertOriginY = svgFont.vertOriginY || 0;
    font.width = svgFont.width || svgFont.unitsPerEm || 1000;
    font.height = svgFont.height || svgFont.unitsPerEm || 1000;
    font.descent = !Number.isNaN(svgFont.descent) ? (svgFont.descent as number) : -font.vertOriginY;
    font.ascent = svgFont.ascent || font.unitsPerEm - font.vertOriginY;
    // Values for font substitution. We're mostly working with icon fonts, so they aren't expected to be substituted.
    // https://docs.microsoft.com/en-us/typography/opentype/spec/os2#sxheight
    font.capHeight = svgFont.capHeight || 0; // 0 is a valid value if "H" glyph doesn't exist
    font.xHeight = svgFont.xHeight || 0; // 0 is a valid value if "x" glyph doesn't exist

    if (typeof svgFont.weightClass !== "undefined") {
        const wght = Number.parseInt(svgFont.weightClass.toString(), 10);

        if (!Number.isNaN(wght)) font.weightClass = wght;
        else {
            // Unknown names are silently ignored
            if (svgFont.weightClass === "normal") font.weightClass = 400;
            if (svgFont.weightClass === "bold") font.weightClass = 700;
        }
    }

    if (typeof svgFont.underlinePosition !== "undefined") {
        font.underlinePosition = svgFont.underlinePosition;
    }
    if (typeof svgFont.underlineThickness !== "undefined") {
        font.underlineThickness = svgFont.underlineThickness;
    }

    const glyphs = font.glyphs;
    const codePoints = font.codePoints;
    const ligatures = font.ligatures;

    function addCodePoint(codePoint: number, glyph: sfnt.Glyph): boolean {
        if (codePoints[codePoint]) {
            // Ignore code points already defined
            return false;
        }
        codePoints[codePoint] = glyph;
        return true;
    }

    // add SVG glyphs to SFNT font
    for (const svgGlyph of svgFont.glyphs) {
        const glyph = new sfnt.Glyph();

        glyph.name = svgGlyph.name ?? "";
        glyph.codes = svgGlyph.ligatureCodes || svgGlyph.unicode; // needed for nice validator error output
        glyph.d = svgGlyph.d;
        glyph.height =
            !Number.isNaN(svgGlyph.height) && svgGlyph.height !== undefined
                ? svgGlyph.height
                : (font.height ?? font.width);
        glyph.width = !Number.isNaN(svgGlyph.width) && svgGlyph.width !== undefined ? svgGlyph.width : font.width;
        glyphs.push(glyph);

        svgGlyph.sfntGlyph = glyph;

        for (const codePoint of svgGlyph.unicode) {
            addCodePoint(codePoint, glyph);
        }
    }

    let missingGlyph: sfnt.Glyph;

    // add missing glyph to SFNT font
    // also, check missing glyph existance and single instance
    if (svgFont.missingGlyph) {
        missingGlyph = new sfnt.Glyph();
        missingGlyph.d = svgFont.missingGlyph.d;
        missingGlyph.height = !Number.isNaN(svgFont.missingGlyph.height)
            ? (svgFont.missingGlyph.height as number)
            : font.height;
        missingGlyph.width = !Number.isNaN(svgFont.missingGlyph.width)
            ? (svgFont.missingGlyph.width as number)
            : font.width;
    } else {
        missingGlyph = glyphs.find((glyph) => glyph.name === ".notdef") as sfnt.Glyph;
    }
    if (!missingGlyph) {
        // no missing glyph and .notdef glyph, we need to create missing glyph
        missingGlyph = new sfnt.Glyph();
    }

    // Create glyphs for all characters used in ligatures
    for (const svgLigature of svgFont.ligatures) {
        const ligature = {
            ligature: svgLigature.ligature,
            unicode: svgLigature.unicode,
            glyph: svgLigature.glyph.sfntGlyph,
        };

        for (const charPoint of ligature.unicode) {
            // We need to have a distinct glyph for each code point so we can reference it in GSUB
            const glyph = new sfnt.Glyph();
            const added = addCodePoint(charPoint, glyph);

            if (added) {
                glyph.name = ucs2.encode([charPoint]);
                glyphs.push(glyph);
            }
        }
        ligatures.push(ligature);
    }

    // Missing Glyph needs to have index 0
    if (glyphs.indexOf(missingGlyph) !== -1) {
        glyphs.splice(glyphs.indexOf(missingGlyph), 1);
    }
    glyphs.unshift(missingGlyph);

    let nextID = 0;

    //add IDs
    for (const glyph of glyphs) {
        glyph.id = nextID;
        nextID++;
    }

    for (const glyph of glyphs) {
        // Calculate accuracy for cubicToQuad transformation
        // For glyphs with height and width smaller than 500 use relative 0.06% accuracy,
        // for larger glyphs use fixed accuracy 0.3.
        const glyphSize = Math.max(glyph.width, glyph.height);
        const accuracy = glyphSize > 500 ? 0.3 : glyphSize * 0.0006;

        //SVG transformations
        const svgPath = new SvgPath(glyph.d)
            .abs()
            .unshort()
            .unarc()
            .iterate((segment: any[], index: number, x: number, y: number) =>
                svg.cubicToQuad(segment, index, x, y, accuracy),
            );
        const sfntContours = svg.toSfntCoutours(svgPath);

        // Add contours to SFNT font
        glyph.contours = sfntContours.map((sfntContour) => {
            const contour = new sfnt.Contour();

            contour.points = sfntContour.map((sfntPoint) => {
                const point = new sfnt.Point();

                point.x = sfntPoint.x;
                point.y = sfntPoint.y;
                point.onCurve = sfntPoint.onCurve;
                return point;
            });

            return contour;
        });
    }

    const ttf = sfnt.toTTF(font);

    return ttf;
}

export default svg2ttf;
